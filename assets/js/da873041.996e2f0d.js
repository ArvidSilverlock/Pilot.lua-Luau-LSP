"use strict";(self.webpackChunkwaste_of_space_wiki=self.webpackChunkwaste_of_space_wiki||[]).push([[7241],{9639:(e,l,t)=>{t.r(l),t.d(l,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"objects/Coupler","title":"Coupler","description":"Will connect to nearby couplers with matching CouplerIDs when activated by Polysilicon. Deactivating via Polysilicon will detach two couplers. Repeatedly emits trigger signals when it is able to connect with another coupler of the same ID.","source":"@site/docs/objects/Coupler.md","sourceDirName":"objects","slug":"/objects/Coupler","permalink":"/Pilot.lua-Luau-LSP/objects/Coupler","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Spawnable","permalink":"/Pilot.lua-Luau-LSP/tags/spawnable"},{"inline":true,"label":"Craftable","permalink":"/Pilot.lua-Luau-LSP/tags/craftable"},{"inline":true,"label":"Programmable","permalink":"/Pilot.lua-Luau-LSP/tags/programmable"},{"inline":true,"label":"Configurable","permalink":"/Pilot.lua-Luau-LSP/tags/configurable"}],"version":"current","frontMatter":{"tags":["Spawnable","Craftable","Programmable","Configurable"]},"sidebar":"objectsSidebar","previous":{"title":"CornerWedge","permalink":"/Pilot.lua-Luau-LSP/objects/CornerWedge"},"next":{"title":"CrossBow","permalink":"/Pilot.lua-Luau-LSP/objects/CrossBow"}}');var n=t(4848),o=t(8453);const i={tags:["Spawnable","Craftable","Programmable","Configurable"]},s=void 0,a={},c=[{value:"Methods",id:"methods",level:2},{value:"GetAttachedCoupler() \u2192 otherCoupler",id:"getattachedcoupler--othercoupler",level:3},{value:"IsCoupled() \u2192 isCoupled",id:"iscoupled--iscoupled",level:3},{value:"Configurables",id:"configurables",level:2},{value:"AutoTrigger",id:"autotrigger",level:3},{value:"CouplerID",id:"couplerid",level:3},{value:"Events",id:"events",level:2},{value:"Couple",id:"couple",level:3},{value:"Decouple",id:"decouple",level:3}];function u(e){const l={h2:"h2",h3:"h3",hr:"hr",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(l.p,{children:"Will connect to nearby couplers with matching CouplerIDs when activated by Polysilicon. Deactivating via Polysilicon will detach two couplers. Repeatedly emits trigger signals when it is able to connect with another coupler of the same ID."}),"\n",(0,n.jsx)(l.p,{children:"It is a craftable and spawnable non-flammable solid."}),"\n",(0,n.jsx)(l.p,{children:"Here is a list of possible sizes that reach the maximum malleability (16) that have integer components: 1x16x1, 1x8x2, 1x4x4, 2x4x2, 4x2x2"}),"\n",(0,n.jsx)(l.p,{children:"At its default size (4x1x4) it has a durability of 1, at its maximum size it has a durability of 2."}),"\n",(0,n.jsxs)(l.p,{children:["By default, its colour is ",(0,n.jsx)("span",{style:{color:"#A3A2A5"},children:"#a3a2a5"}),"."]}),"\n",(0,n.jsxs)(l.p,{children:["It requires 10 ",(0,n.jsx)("code",{children:"Iron"}),", to be crafted."]}),"\n",(0,n.jsx)(l.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"getattachedcoupler--othercoupler",children:"GetAttachedCoupler() \u2192 otherCoupler"}),"\n",(0,n.jsxs)(l.p,{children:["Returns a reference to the current connected coupler, will return ",(0,n.jsx)("code",{children:"nil"})," if no other coupler is connected."]}),"\n",(0,n.jsxs)(l.p,{children:["The ",(0,n.jsx)("b",{children:"otherCoupler"})," return is a ",(0,n.jsx)("code",{children:"Coupler"}),". It can also be ",(0,n.jsx)("code",{children:"nil"}),"."]}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"iscoupled--iscoupled",children:"IsCoupled() \u2192 isCoupled"}),"\n",(0,n.jsx)(l.p,{children:"Returns whether or not the coupler is currently attached to another coupler."}),"\n",(0,n.jsxs)(l.p,{children:["The ",(0,n.jsx)("b",{children:"isCoupled"})," return is a ",(0,n.jsx)("code",{children:"boolean"}),"."]}),"\n",(0,n.jsx)(l.h2,{id:"configurables",children:"Configurables"}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"autotrigger",children:"AutoTrigger"}),"\n",(0,n.jsxs)(l.p,{children:["Whether or not the coupler should emit trigger signals while in range of another valid coupler. It is a ",(0,n.jsx)("code",{children:"boolean"}),"."]}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"couplerid",children:"CouplerID"}),"\n",(0,n.jsxs)(l.p,{children:["The ID of this coupler. It is a ",(0,n.jsx)("code",{children:"string"}),"."]}),"\n",(0,n.jsx)(l.h2,{id:"events",children:"Events"}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"couple",children:"Couple"}),"\n",(0,n.jsx)(l.hr,{}),"\n",(0,n.jsx)(l.h3,{id:"decouple",children:"Decouple"})]})}function d(e={}){const{wrapper:l}={...(0,o.R)(),...e.components};return l?(0,n.jsx)(l,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,l,t)=>{t.d(l,{R:()=>i,x:()=>s});var r=t(6540);const n={},o=r.createContext(n);function i(e){const l=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(l):{...l,...e}}),[l,e])}function s(e){let l;return l=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(o.Provider,{value:l},e.children)}}}]);