"use strict";(self.webpackChunkwaste_of_space_wiki=self.webpackChunkwaste_of_space_wiki||[]).push([[506],{7247:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"objects/LifeSensor","title":"LifeSensor","description":"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.","source":"@site/docs/objects/LifeSensor.md","sourceDirName":"objects","slug":"/objects/LifeSensor","permalink":"/Pilot.lua-Luau-LSP/objects/LifeSensor","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Logic","permalink":"/Pilot.lua-Luau-LSP/tags/logic"},{"inline":true,"label":"Spawnable","permalink":"/Pilot.lua-Luau-LSP/tags/spawnable"},{"inline":true,"label":"Craftable","permalink":"/Pilot.lua-Luau-LSP/tags/craftable"},{"inline":true,"label":"Programmable","permalink":"/Pilot.lua-Luau-LSP/tags/programmable"},{"inline":true,"label":"Non-Configurable","permalink":"/Pilot.lua-Luau-LSP/tags/non-configurable"}],"version":"current","frontMatter":{"tags":["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},"sidebar":"objectsSidebar","previous":{"title":"Lead","permalink":"/Pilot.lua-Luau-LSP/objects/Lead"},"next":{"title":"Light","permalink":"/Pilot.lua-Luau-LSP/objects/Light"}}');var r=t(4848),s=t(8453);const i={tags:["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},o=void 0,l={},h=[{value:"Methods",id:"methods",level:2},{value:"GetPlayers() \u2192 players",id:"getplayers--players",level:3},{value:"GetReading() \u2192 reading",id:"getreading--reading",level:3},{value:"ListPlayers() \u2192 players",id:"listplayers--players",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.\nIt is used in alien technology to hunt down organisms such as players."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"-- Get access to the Waste of Space provided 'module' that lets us access player usernames if\n-- we provide it a `UserId`.\nlocal players = require(\"players\")\n\n-- Create a whitelist of `UserId`s, it uses a 'dictionary' format, where the keys are the `UserId`s\n-- and the values are `true` so we can access whether someone is whitelisted by doing `WHITELIST[userId]`\n-- rather than `table.find(WHITELIST, userId)`, which is both cleaner and \"faster\" (faster is in quotes\n-- because the performance difference is minimal if you only have a few people in your whitelist)\nlocal WHITELIST = {\n    [1178125707] = true,\n}\n\n-- Try and get the life sensor, throw an informative error if we don't find it using `assert`.\nlocal lifeSensor = assert(GetPart(\"LifeSensor\"), \"no life sensor connected\")\n\n-- Create a 'function' that we'll run whenever we find a player outside of the whitelist.\n-- You may notice the `: number` and `: CFrame`, these are 'types', they tell luau what types\n-- of values variables are storing (the `CFrame?` just means `CFrame` or `nil`), which helps\n-- with autofill and linting (linting is the squiggly lines that show up when you do bad things)\nlocal function foundThreat(threatUserId: number, position: CFrame?)\n    -- Get the player's username from their `UserId` using the `players` module that is\n    -- provided by Waste of Space via `require(\"players\")`.\n    local threatUsername = players:GetUsername(threatUserId)\n    \n    -- If we have been given the position (and therefore the player is within the life sensor range)\n    -- then we can utilise the player's position in our operations.\n    if position then\n        -- What we do here is get the position of the target player *relative* to the life sensor,\n        -- then get the 'magnitude' of the resulting value, which is the fancy way of saying 'length'.\n        local distance = (position.Position - lifeSensor.Position).Magnitude\n\n        -- Output the player's username and their distance.\n        print(`There is a threat! Their name is {threatUsername} and they are {math.floor(distance)} studs away!`)\n    else\n        -- Output just the player's username, and add a note about how they're too far away to know their distance.\n        print(`There is a threat! Their name is {threatUsername}! They are too far away to tell their distance.`)\n    end\nend\n\n-- Connect to the `Loop` event of the `Microcontroller` that is running the code,\n-- this will make the code within run precisely every game tick.\nMicrocontroller.Loop:Connect(function()\n    -- Get an 'array' of the player `UserId`s, this function ignores the range limit.\n    local presenceReading = lifeSensor:ListPlayers()\n\n    -- This one returns a 'dictionary' where the keys are the player `UserId's`, and\n    -- the values are the positions of the specific players, but it only includes\n    -- players within 2,000 studs of the `LifeSensor`, which is why we need\n    -- the result of `ListPlayers`.\n    local positionalReading = lifeSensor:GetPlayers()\n    \n    -- Iterate over each of the players returned by `ListPlayers`, the 'index' variable is\n    -- called `_` as is customary when defining a variable that is not ever used.\n    for _, userId in presenceReading do\n        -- If the user is whitelisted, skip to the next player using a `continue` statement.\n        if WHITELIST[userId] then continue end\n\n        -- Here, we try and get the player's position from the `GetPlayers` dictionary, if the\n        -- player is outside of the `LifeSensor`'s range, this will be `nil` and *won't* throw\n        -- any sort of error.\n        local playerPosition = positionalReading[userId]\n\n        -- Merely call the `foundThread` function, giving it the user who we're talking about,\n        -- along with their position (their position *may* or *may not* be specified.)]\n\n        -- Note: If you were to do some computation within `foundThread` that takes a lot of\n        --       time (or maybe has a `task.wait` or two), you would want to do something\n        --       like `task.spawn(foundThread, userId, playerPosition)` instead, as this\n        --       will allow this function to keep looking for other players whilst the\n        --       `foundThreat` function is running (rather than waiting for it to finish).\n        --       Look into the roblox task scheduler if you want to know more.\n        foundThreat(userId, playerPosition)\n    end\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"It is a craftable and spawnable non-flammable solid."}),"\n",(0,r.jsx)(n.p,{children:"It cannot be resized."}),"\n",(0,r.jsx)(n.p,{children:"At its default size (2x3x2) it has a durability of 1."}),"\n",(0,r.jsxs)(n.p,{children:["By default, its colour is ",(0,r.jsx)("span",{style:{color:"#00FF00"},children:"#00ff00"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["It requires 15 ",(0,r.jsx)("code",{children:"Grass"}),", 25 ",(0,r.jsx)("code",{children:"Quartz"}),", and 5 ",(0,r.jsx)("code",{children:"Wire"})," to be crafted."]}),"\n",(0,r.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"getplayers--players",children:"GetPlayers() \u2192 players"}),"\n",(0,r.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,r.jsx)("i",{children:"player"})," ",(0,r.jsx)("code",{children:"UserId"}),"s and the values are ",(0,r.jsx)("i",{children:"player"})," CFrames. Only has a 2,000 stud range."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)("b",{children:"players"})," return is a dictionary of player ",(0,r.jsx)("code",{children:"UserId"}),"s to their world CFrames. It is a dictionary with keys that are ",(0,r.jsx)("code",{children:"number"}),"s and values that are ",(0,r.jsx)("code",{children:"CFrame"}),"s."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"getreading--reading",children:"GetReading() \u2192 reading"}),"\n",(0,r.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,r.jsx)("i",{children:"humanoid"})," names and the values are ",(0,r.jsx)("i",{children:"humanoid"})," positions. Only has a 2,000 stud range."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)("b",{children:"reading"})," return is a dictionary of humanoid names to their world positions. It is a dictionary with keys that are ",(0,r.jsx)("code",{children:"number"}),"s and values that are ",(0,r.jsx)("code",{children:"Vector3"}),"s."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"listplayers--players",children:"ListPlayers() \u2192 players"}),"\n",(0,r.jsxs)(n.p,{children:["Returns an array of player ",(0,r.jsx)("code",{children:"UserId"}),"s. Ignores the 2,000 stud range limit."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)("b",{children:"players"})," return is a ",(0,r.jsx)("code",{children:"number"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);