"use strict";(self.webpackChunkwaste_of_space_wiki=self.webpackChunkwaste_of_space_wiki||[]).push([[729],{617:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"objects/Keyboard","title":"Keyboard","description":"Similar to a button, except is programmable to take more than one key input.","source":"@site/docs/objects/Keyboard.md","sourceDirName":"objects","slug":"/objects/Keyboard","permalink":"/Pilot.lua-Luau-LSP/objects/Keyboard","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Logic","permalink":"/Pilot.lua-Luau-LSP/tags/logic"},{"inline":true,"label":"Spawnable","permalink":"/Pilot.lua-Luau-LSP/tags/spawnable"},{"inline":true,"label":"Craftable","permalink":"/Pilot.lua-Luau-LSP/tags/craftable"},{"inline":true,"label":"Programmable","permalink":"/Pilot.lua-Luau-LSP/tags/programmable"},{"inline":true,"label":"Non-Configurable","permalink":"/Pilot.lua-Luau-LSP/tags/non-configurable"}],"version":"current","frontMatter":{"tags":["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},"sidebar":"objectsSidebar","previous":{"title":"Katana","permalink":"/Pilot.lua-Luau-LSP/objects/Katana"},"next":{"title":"Kiln","permalink":"/Pilot.lua-Luau-LSP/objects/Kiln"}}');var s=t(4848),i=t(8453);const a={tags:["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},l=void 0,o={},c=[{value:"Methods",id:"methods",level:2},{value:"SimulateKeyPress(key, player)",id:"simulatekeypresskey-player",level:3},{value:"SimulateTextInput(input, player)",id:"simulatetextinputinput-player",level:3},{value:"SimulateUserInput()",id:"simulateuserinput",level:3},{value:"Events",id:"events",level:2},{value:"KeyPressed(key, keyName, userId)",id:"keypressedkey-keyname-userid",level:3},{value:"TextInputted",id:"textinputted",level:3},{value:"UserInput(inputObject, userId)",id:"userinputinputobject-userid",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Similar to a button, except is programmable to take more than one key input.\nCan be attached to a vehicle seat or clicked by a player."}),"\n",(0,s.jsx)(n.p,{children:"It is a craftable and spawnable non-flammable solid."}),"\n",(0,s.jsx)(n.p,{children:"Here is a list of possible sizes that reach the maximum malleability (75) that have integer components: 1x75x1, 1x25x3, 1x15x5, 3x5x5"}),"\n",(0,s.jsx)(n.p,{children:"At its default size (5x0.50x2) it has a durability of 1, at its maximum size it has a durability of 3."}),"\n",(0,s.jsxs)(n.p,{children:["By default, its colour is ",(0,s.jsx)("span",{style:{color:"#DCDCDD"},children:"#dcdcdd"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It requires 10 ",(0,s.jsx)("code",{children:"Button"}),", 4 ",(0,s.jsx)("code",{children:"Quartz"}),", and 5 ",(0,s.jsx)("code",{children:"Silicon"})," to be crafted."]}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"simulatekeypresskey-player",children:"SimulateKeyPress(key, player)"}),"\n",(0,s.jsx)(n.p,{children:"Simulates a key press just like you would press a key on the keyboard."}),"\n",(0,s.jsxs)(n.p,{children:["The parameters for ",(0,s.jsx)("code",{children:"SimulateKeyPress"})," are as follows:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"key"})," parameter is a ",(0,s.jsx)("code",{children:"string"}),". It can also be ",(0,s.jsx)("code",{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"player"})," parameter is a ",(0,s.jsx)("code",{children:"string"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"simulatetextinputinput-player",children:"SimulateTextInput(input, player)"}),"\n",(0,s.jsx)(n.p,{children:"Simulates text input just like you would type in the keyboard and enter."}),"\n",(0,s.jsxs)(n.p,{children:["The parameters for ",(0,s.jsx)("code",{children:"SimulateTextInput"})," are as follows:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"input"})," parameter is a ",(0,s.jsx)("code",{children:"string"}),". It can also be ",(0,s.jsx)("code",{children:"nil"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"player"})," parameter is a ",(0,s.jsx)("code",{children:"string"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"simulateuserinput",children:"SimulateUserInput()"}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"keypressedkey-keyname-userid",children:"KeyPressed(key, keyName, userId)"}),"\n",(0,s.jsx)(n.p,{children:"Fires when the user presses a key."}),"\n",(0,s.jsxs)(n.p,{children:["The parameters for ",(0,s.jsx)("code",{children:"KeyPressed"})," are as follows:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"key"})," parameter is the ",(0,s.jsx)("code",{children:"Enum.KeyCode"})," of the key that was pressed. It is an ",(0,s.jsx)("code",{children:"Enum.KeyCode"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"keyName"})," parameter is the letter of the key that was pressed. If the key is non-printable (i.e. shift or backspace) ",(0,s.jsx)("code",{children:"keyString"})," will be an empty string. If ",(0,s.jsx)("code",{children:"Shift"})," is held, it will be capitalised. It is a ",(0,s.jsx)("code",{children:"string"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"userId"})," parameter is the ",(0,s.jsx)("code",{children:"UserId"})," of the player who pressed the key. It is a ",(0,s.jsx)("code",{children:"number"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- Get all of the necessary parts and throw a useful error if something isn\'t found.\nlocal anchor = assert(GetPart("Anchor"), "no anchor connected")\nlocal thrusterSwitch = assert(GetPart("Switch"), "no switch connected")\nlocal keyboard = assert(GetPart("Keyboard"), "no keyboard connected")\n\n-- Define the `UserId`s of people who are allowed.\nlocal WHITELIST = {\n    [1178125707] = true,\n}\n\n-- Create a dictionary of what key to press to what code to run\nlocal BINDS = {\n    -- Toggle the anchor state when `R` is pressed.\n    [Enum.KeyCode.R] = function()\n        anchor.Anchor = not anchor.Anchor\n    end,\n    -- Toggle the switch state when `X` is pressed.\n    [Enum.KeyCode.X] = function()\n        thrusterSwitch.SwitchValue = not thrusterSwitch.SwitchValue\n    end,\n}\n\n-- Connect to the `keyboard.KeyPressed` event, we don\'t need the `keyName` variable,\n-- so we\'ll call it `_` as to say "we\'re not going to use this" to anyone reading the code.\nkeyboard.KeyPressed:Connect(function(key, _, userId)\n    -- If the user *isn\'t* in the whitelist, *cancel* this function using `return`.\n    if not WHITELIST[userId] then return end\n\n    -- Try and find the piece of code to run for the key that was pressed, if we don\'t find\n    -- it, cancel, like it\'s done when the user isn\'t in the whitelist.\n    local callback = BINDS[key]\n    if not callback then return end\n\n    -- Run the piece of code!\n    callback()\nend)\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"textinputted",children:"TextInputted"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"userinputinputobject-userid",children:"UserInput(inputObject, userId)"}),"\n",(0,s.jsxs)(n.p,{children:["Will fire when a user presses a key, it is already filtered to ",(0,s.jsx)("code",{children:"gameProcessedEvent"})," being false."]}),"\n",(0,s.jsxs)(n.p,{children:["The parameters for ",(0,s.jsx)("code",{children:"UserInput"})," are as follows:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"inputObject"})," parameter is the ",(0,s.jsx)("code",{children:"UserInputObject"})," produced by the player, is not whitelisted to any ",(0,s.jsx)("code",{children:"Enum.UserInputState"}),". It is a ",(0,s.jsx)("code",{children:"UserInputObject"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("b",{children:"userId"})," parameter is the ",(0,s.jsx)("code",{children:"UserId"})," of the player who pressed the input. It is a ",(0,s.jsx)("code",{children:"number"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local UPDATES_PER_TICK = 16 -- How many times to rotate per tick, higher is smoother.\nlocal ANGLE_INCREMENT = 4 -- Every 1/UPDATES_PER_TICK seconds increment the servo angle by this.\nlocal SHIFT_HELD_MULTIPLIER = 0.25 -- When shift is held, multiply the angle increment by this.\n\n-- Who can rotate the servos.\nlocal WHITELIST = {\n    [1178125707] = true,\n}\n\n-- Get references to all the hardware, everything is *required* except for the\n-- seat, which is optional.\nlocal yawServo = assert(GetPartFromPort(1, "Servo"), "no yaw servo connected")\nlocal pitchServo = assert(GetPartFromPort(2, "Servo"), "no pitch servo connected")\nlocal keyboard = assert(GetPart("Keyboard"), "no keyboard connected")\nlocal seat = GetPart("Seat")\n\n-- Make sure the servos are wired properly!\nassert(yawServo ~= pitchServo, "there is only one servo connected")\n\nlocal servoAngles = {}\nlocal heldKeys = {}\n\nlocal function incrementAngle(servo, direction)\n    -- Make the `ANGLE_INCREMENT` negative if the direction is specified as `-1`\n    -- with a bit of multiplication.\n    local baseIncrement = ANGLE_INCREMENT * direction\n\n    -- If we need to initialise the target angle of the servo:\n    if not servoAngles[servo] then\n        -- Rotate it back to 0 degrees and initialise the current state.\n        servo:SetAngle(0)\n        servoAngles[servo] = 0\n    end\n\n    -- Here we return a new function, that when called, applies the angle increment\n    -- operation to the servo, this is a trick called a "closure".\n    return function()\n        -- Calculate the new angle, check if we\'re holding shift, if we are multiply\n        -- the increment by the `SHIFT_HELD_MULTIPLIER`\n        local multiplier = if heldKeys[Enum.KeyCode.LeftShift] then SHIFT_HELD_MULTIPLIER else 1\n        local currentAngle = baseIncrement * multiplier\n\n        -- Update both the real and internal servo angle.\n        servo:SetAngle(currentAngle)\n        servoAngles[servo] = currentAngle\n    end\nend\n\n-- Register all of the angle incrementing functions that should keep running\n-- whilst the user keeps holding the bind.\nlocal HOLD_BINDS = {\n    [Enum.KeyCode.W] = incrementAngle(pitchServo, 1),\n    [Enum.KeyCode.A] = incrementAngle(yawServo, 1),\n    [Enum.KeyCode.S] = incrementAngle(pitchServo, -1),\n    [Enum.KeyCode.D] = incrementAngle(yawServo, -1),\n}\n\n-- Register all of the general binds that only run on key down.\nlocal BINDS = {\n    [Enum.KeyCode.F] = function()\n        TriggerPort(3) -- Assume port 3 has something like guns!\n    end,\n}\n\n-- If we have a seat, we can detect when the user gets up and clear all the\n-- held keys as if they stopped inputting.\nif seat then\n    seat.OccupantChanged:Connect(function(occupant)\n        if occupant then return end -- If someone just sat down, cancel\n        table.clear(heldKeys) -- Whereas if someone got up, clear the held keys\n    end)\nelse\n    -- Provide a warning about issues that might occur when no seat is connected.\n    warn([[There is no seat connected to the microcontroller!\n      If a player jumps whilst holding an input, the input will get stuck!]])\nend\n\nkeyboard.UserInput:Connect(function(input, userId)\n    -- Check if the user is whitelisted, if they\'re not, cancel.\n    if not WHITELIST[userId] then return end\n\n    -- If the bind pressed has a function to run on key down, run it.\n    if BINDS[input.KeyCode] then\n        local callback = BINDS[input.KeyCode]\n        callback()\n    end\n\n    -- If the user *started* pressing the key, register it as held, otherwise\n    -- deregister it.\n    if input.UserInputState == Enum.UserInputState.Begin then\n        heldKeys[input.KeyCode] = true\n    elseif input.UserInputState == Enum.UserInputState.End then\n        heldKeys[input.KeyCode] = nil\n    end\nend)\n\n-- For each tick we want to call all the functions that should run for held keys.\n-- You could alternatively use a simple `while true do` loop, but this keeps it\n-- tick aligned, and tick alignment may provide benefits in some cases.\nMicrocontroller.Loop:Connect(function(tickDuration)\n    for index = 1, UPDATES_PER_TICK do\n        for key, callback in HOLD_BINDS do\n            -- If we\'re not holding this bind, look at the next bind.\n            if not heldKeys[key] then continue end\n            callback()\n        end\n\n        -- Wait a little for for the next time we should update.\n        task.wait(tickDuration / UPDATES_PER_TICK)\n    end\nend)\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);