"use strict";(self.webpackChunkwaste_of_space_wiki=self.webpackChunkwaste_of_space_wiki||[]).push([[5940],{5570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"objects/LifeSensor","title":"LifeSensor","description":"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.","source":"@site/docs/objects/LifeSensor.mdx","sourceDirName":"objects","slug":"/objects/LifeSensor","permalink":"/Pilot.lua-Luau-LSP/objects/LifeSensor","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Logic","permalink":"/Pilot.lua-Luau-LSP/tags/logic"},{"inline":true,"label":"Spawnable","permalink":"/Pilot.lua-Luau-LSP/tags/spawnable"},{"inline":true,"label":"Craftable","permalink":"/Pilot.lua-Luau-LSP/tags/craftable"},{"inline":true,"label":"Programmable","permalink":"/Pilot.lua-Luau-LSP/tags/programmable"},{"inline":true,"label":"Non-Configurable","permalink":"/Pilot.lua-Luau-LSP/tags/non-configurable"}],"version":"current","frontMatter":{"tags":["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},"sidebar":"objectsSidebar","previous":{"title":"Lead","permalink":"/Pilot.lua-Luau-LSP/objects/Lead"},"next":{"title":"Light","permalink":"/Pilot.lua-Luau-LSP/objects/Light"}}');var i=t(4848),r=t(8453),s=t(9907);const o={tags:["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},l=void 0,h={},d=[{value:"Methods",id:"Methods",level:2},{value:"GetPlayers()",id:"GetPlayers",level:3},{value:"GetReading()",id:"GetReading",level:3},{value:"ListPlayers()",id:"ListPlayers",level:3}];function c(e){const n={code:"code",hr:"hr",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.\nIt is used in alien technology to hunt down organisms such as players."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Get access to the Waste of Space provided 'module' that lets us access player usernames if\n-- we provide it a `UserId`.\nlocal players = require(\"players\")\n\n-- Create a whitelist of `UserId`s, it uses a 'dictionary' format, where the keys are the `UserId`s\n-- and the values are `true` so we can access whether someone is whitelisted by doing `WHITELIST[userId]`\n-- rather than `table.find(WHITELIST, userId)`, which is both cleaner and \"faster\" (faster is in quotes\n-- because the performance difference is minimal if you only have a few people in your whitelist)\nlocal WHITELIST = {\n    [1178125707] = true,\n}\n\n-- Try and get the life sensor, throw an informative error if we don't find it using `assert`.\nlocal lifeSensor = assert(GetPart(\"LifeSensor\"), \"no life sensor connected\")\n\n-- Create a 'function' that we'll run whenever we find a player outside of the whitelist.\n-- You may notice the `: number` and `: CFrame`, these are 'types', they tell luau what types\n-- of values variables are storing (the `CFrame?` just means `CFrame` or `nil`), which helps\n-- with autofill and linting (linting is the squiggly lines that show up when you do bad things)\nlocal function foundThreat(threatUserId: number, position: CFrame?)\n    -- Get the player's username from their `UserId` using the `players` module that is\n    -- provided by Waste of Space via `require(\"players\")`.\n    local threatUsername = players:GetUsername(threatUserId)\n    \n    -- If we have been given the position (and therefore the player is within the life sensor range)\n    -- then we can utilise the player's position in our operations.\n    if position then\n        -- What we do here is get the position of the target player *relative* to the life sensor,\n        -- then get the 'magnitude' of the resulting value, which is the fancy way of saying 'length'.\n        local distance = (position.Position - lifeSensor.Position).Magnitude\n\n        -- Output the player's username and their distance.\n        print(`There is a threat! Their name is {threatUsername} and they are {math.floor(distance)} studs away!`)\n    else\n        -- Output just the player's username, and add a note about how they're too far away to know their distance.\n        print(`There is a threat! Their name is {threatUsername}! They are too far away to tell their distance.`)\n    end\nend\n\n-- Connect to the `Loop` event of the `Microcontroller` that is running the code,\n-- this will make the code within run precisely every game tick.\nMicrocontroller.Loop:Connect(function()\n    -- Get an 'array' of the player `UserId`s, this function ignores the range limit.\n    local presenceReading = lifeSensor:ListPlayers()\n\n    -- This one returns a 'dictionary' where the keys are the player `UserId's`, and\n    -- the values are the positions of the specific players, but it only includes\n    -- players within 2,000 studs of the `LifeSensor`, which is why we need\n    -- the result of `ListPlayers`.\n    local positionalReading = lifeSensor:GetPlayers()\n    \n    -- Iterate over each of the players returned by `ListPlayers`, the 'index' variable is\n    -- called `_` as is customary when defining a variable that is not ever used.\n    for _, userId in presenceReading do\n        -- If the user is whitelisted, skip to the next player using a `continue` statement.\n        if WHITELIST[userId] then continue end\n\n        -- Here, we try and get the player's position from the `GetPlayers` dictionary, if the\n        -- player is outside of the `LifeSensor`'s range, this will be `nil` and *won't* throw\n        -- any sort of error.\n        local playerPosition = positionalReading[userId]\n\n        -- Merely call the `foundThread` function, giving it the user who we're talking about,\n        -- along with their position (their position *may* or *may not* be specified.)]\n\n        -- Note: If you were to do some computation within `foundThread` that takes a lot of\n        --       time (or maybe has a `task.wait` or two), you would want to do something\n        --       like `task.spawn(foundThread, userId, playerPosition)` instead, as this\n        --       will allow this function to keep looking for other players whilst the\n        --       `foundThreat` function is running (rather than waiting for it to finish).\n        --       Look into the roblox task scheduler if you want to know more.\n        foundThreat(userId, playerPosition)\n    end\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is a craftable and spawnable non-flammable solid."}),"\n",(0,i.jsx)(n.p,{children:"It cannot be resized."}),"\n",(0,i.jsx)(n.p,{children:"At its default size (2x3x2) it has a durability of 1."}),"\n",(0,i.jsxs)(n.p,{children:["By default, its colour is ",(0,i.jsx)("span",{style:{color:"#00FF00"},children:"#00ff00"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It requires 15 ",(0,i.jsx)("code",{children:"Grass"}),", 25 ",(0,i.jsx)("code",{children:"Quartz"}),", and 5 ",(0,i.jsx)("code",{children:"Wire"})," to be crafted."]}),"\n",(0,i.jsx)(s.A,{id:"Methods",group:"group",children:"Methods"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"GetPlayers",group:"method",children:"GetPlayers() \u2192 players"}),"\n",(0,i.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,i.jsx)("i",{children:"player"})," ",(0,i.jsx)("code",{children:"UserId"}),"s and the values are ",(0,i.jsx)("i",{children:"player"})," CFrames. Only has a 2,000 stud range."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"players"})," return is a dictionary of player ",(0,i.jsx)("code",{children:"UserId"}),"s to their world CFrames. It is a dictionary with keys that are ",(0,i.jsx)("code",{children:"number"}),"s and values that are ",(0,i.jsx)("code",{children:"CFrame"}),"s."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"GetReading",group:"method",children:"GetReading() \u2192 reading"}),"\n",(0,i.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,i.jsx)("i",{children:"humanoid"})," names and the values are ",(0,i.jsx)("i",{children:"humanoid"})," positions. Only has a 2,000 stud range."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"reading"})," return is a dictionary of humanoid names to their world positions. It is a dictionary with keys that are ",(0,i.jsx)("code",{children:"number"}),"s and values that are ",(0,i.jsx)("code",{children:"Vector3"}),"s."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"ListPlayers",group:"method",children:"ListPlayers() \u2192 players"}),"\n",(0,i.jsxs)(n.p,{children:["Returns an array of player ",(0,i.jsx)("code",{children:"UserId"}),"s. Ignores the 2,000 stud range limit."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"players"})," return is a ",(0,i.jsx)("code",{children:"number"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1113:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var a=t(4848);function i(e){return(0,a.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,a.jsx)("path",{fill:"currentColor",d:"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"})})}},9907:(e,n,t)=>{t.d(n,{A:()=>y});t(6540);var a=t(4164),i=t(1312),r=t(6342),s=t(5293),o=t(8774),l=t(3427),h=t(2303),d=t(4848);function c(e){let{children:n,fallback:t}=e;return(0,h.A)()?(0,d.jsx)(d.Fragment,{children:n?.()}):t??null}var u=t(1409),p=t(1113);function f(e){return(0,d.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,d.jsx)("path",{fill:"currentColor",d:"M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"})})}const m={anchorWithStickyNavbar:"anchorWithStickyNavbar_wkc4",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_m_Ui"};var g=t(6347);function y(e){let{id:n,group:t,...h}=e;const y=(0,l.A)(),{navbar:{hideOnScroll:w}}=(0,r.p)();y.collectAnchor(n);const b="group"===t?"h2":"h3",x=(0,i.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:n}),j=(0,i.T)({id:"theme.common.markdownLinkTitle",message:"Copy markdown link to {heading}",description:"Markdown for link to heading"},{heading:n}),v=(0,s.G)().colorMode,k=(0,g.zy)().pathname;return(0,d.jsxs)(b,{...h,className:(0,a.A)("anchor",w?m.anchorWithHideOnScrollNavbar:m.anchorWithStickyNavbar,h.className),id:n,children:[h.children,(0,d.jsx)(o.A,{className:"icon-link",to:`#${n}`,"aria-label":x,title:x,children:(0,d.jsx)(f,{width:"0.75em",height:"0.75em"})}),(0,d.jsx)(c,{children:()=>{const e=location.pathname.split("/").filter(Boolean),a=e[e.length-1],i=`[${"group"==t?`\`${a}\`'s ${n.toLowerCase()}`:"method"==t?`\`${a}:${n}()\``:`\`${a}.${n}\``}](<${`${window.location.origin}${k}#${n}`}>)`;return(0,d.jsx)("a",{className:"icon-link","aria-label":j,title:j,onClick:()=>{u.oR.dark((0,d.jsxs)("a",{children:["Copied the ",(0,d.jsx)("code",{children:n})," link to clipboard."]}),{position:"top-center",autoClose:1e3,hideProgressBar:!0,closeOnClick:!0,pauseOnHover:!0,draggable:!1,progress:void 0,theme:v,transition:u.GP}),navigator.clipboard.writeText(i)},children:(0,d.jsx)(p.A,{width:"0.75em",height:"0.75em"})})}})]})}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);