"use strict";(self.webpackChunkwaste_of_space_wiki=self.webpackChunkwaste_of_space_wiki||[]).push([[5940],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(96540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},56046:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(96540),i=t(34164),r=t(21312),s=t(6342),o=(t(38193),t(89532)),l=t(89466),h=t(74848);const d=a.createContext(void 0),c="theme";(0,l.Wf)(c);function u(){const e=(0,a.useContext)(d);if(null==e)throw new o.dV("ColorModeProvider","Please see https://docusaurus.io/docs/api/themes/configuration#use-color-mode.");return e}var p=t(28774),f=t(63427),m=t(92303);function g(e){let{children:n,fallback:t}=e;return(0,m.A)()?(0,h.jsx)(h.Fragment,{children:n?.()}):t??null}var y=t(61409),w=t(81113);function b(e){return(0,h.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,h.jsx)("path",{fill:"currentColor",d:"M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"})})}const x={anchorWithStickyNavbar:"anchorWithStickyNavbar_wkc4",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_m_Ui"};var v=t(56347);function j(e){let{id:n,group:t,...a}=e;const o=(0,f.A)(),{navbar:{hideOnScroll:l}}=(0,s.p)();o.collectAnchor(n);const d="group"===t?"h2":"h3",c=(0,r.T)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:n}),m=(0,r.T)({id:"theme.common.markdownLinkTitle",message:"Copy markdown link to {heading}",description:"Markdown for link to heading"},{heading:n}),j=(0,v.zy)().pathname;return(0,h.jsxs)(d,{...a,className:(0,i.A)("anchor",l?x.anchorWithHideOnScrollNavbar:x.anchorWithStickyNavbar,a.className),id:n,children:[a.children,(0,h.jsx)(p.A,{className:"icon-link",to:`#${n}`,"aria-label":c,title:c,children:(0,h.jsx)(b,{width:"0.75em",height:"0.75em"})}),(0,h.jsx)(g,{children:()=>{const e=location.pathname.split("/").filter(Boolean),a=e[e.length-1],i=`[${"group"==t?`\`${a}\`'s ${n.toLowerCase()}`:"method"==t?`\`${a}:${n}()\``:`\`${a}.${n}\``}](<${`${window.location.origin}${j}#${n}`}>)`;return(0,h.jsx)("a",{className:"icon-link","aria-label":m,title:m,onClick:()=>{y.oR.dark((0,h.jsxs)("a",{children:["Copied the ",(0,h.jsx)("code",{children:n})," link to clipboard."]}),{position:"top-center",autoClose:1e3,hideProgressBar:!0,closeOnClick:!0,pauseOnHover:!0,draggable:!1,progress:void 0,theme:u().colorMode,transition:y.GP}),navigator.clipboard.writeText(i)},children:(0,h.jsx)(w.A,{width:"0.75em",height:"0.75em"})})}})]})}},75570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"objects/LifeSensor","title":"LifeSensor","description":"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.","source":"@site/docs/objects/LifeSensor.mdx","sourceDirName":"objects","slug":"/objects/LifeSensor","permalink":"/Pilot.lua-Luau-LSP/objects/LifeSensor","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Logic","permalink":"/Pilot.lua-Luau-LSP/tags/logic"},{"inline":true,"label":"Spawnable","permalink":"/Pilot.lua-Luau-LSP/tags/spawnable"},{"inline":true,"label":"Craftable","permalink":"/Pilot.lua-Luau-LSP/tags/craftable"},{"inline":true,"label":"Programmable","permalink":"/Pilot.lua-Luau-LSP/tags/programmable"},{"inline":true,"label":"Non-Configurable","permalink":"/Pilot.lua-Luau-LSP/tags/non-configurable"}],"version":"current","frontMatter":{"tags":["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},"sidebar":"objectsSidebar","previous":{"title":"Lead","permalink":"/Pilot.lua-Luau-LSP/objects/Lead"},"next":{"title":"Light","permalink":"/Pilot.lua-Luau-LSP/objects/Light"}}');var i=t(74848),r=t(28453),s=t(56046);const o={tags:["Logic","Spawnable","Craftable","Programmable","Non-Configurable"]},l=void 0,h={},d=[{value:"Methods",id:"Methods",level:2},{value:"GetPlayers()",id:"GetPlayers",level:3},{value:"GetReading()",id:"GetReading",level:3},{value:"ListPlayers()",id:"ListPlayers",level:3}];function c(e){const n={code:"code",hr:"hr",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Senses and detects organic life up to a distance of 2000 studs. It only has a purpose within programming.\nIt is used in alien technology to hunt down organisms such as players."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Get access to the Waste of Space provided 'module' that lets us access player usernames if\n-- we provide it a `UserId`.\nlocal players = require(\"players\")\n\n-- Create a whitelist of `UserId`s, it uses a 'dictionary' format, where the keys are the `UserId`s\n-- and the values are `true` so we can access whether someone is whitelisted by doing `WHITELIST[userId]`\n-- rather than `table.find(WHITELIST, userId)`, which is both cleaner and \"faster\" (faster is in quotes\n-- because the performance difference is minimal if you only have a few people in your whitelist)\nlocal WHITELIST = {\n    [1178125707] = true,\n}\n\n-- Try and get the life sensor, throw an informative error if we don't find it using `assert`.\nlocal lifeSensor = assert(GetPart(\"LifeSensor\"), \"no life sensor connected\")\n\n-- Create a 'function' that we'll run whenever we find a player outside of the whitelist.\n-- You may notice the `: number` and `: CFrame`, these are 'types', they tell luau what types\n-- of values variables are storing (the `CFrame?` just means `CFrame` or `nil`), which helps\n-- with autofill and linting (linting is the squiggly lines that show up when you do bad things)\nlocal function foundThreat(threatUserId: number, position: CFrame?)\n    -- Get the player's username from their `UserId` using the `players` module that is\n    -- provided by Waste of Space via `require(\"players\")`.\n    local threatUsername = players:GetUsername(threatUserId)\n    \n    -- If we have been given the position (and therefore the player is within the life sensor range)\n    -- then we can utilise the player's position in our operations.\n    if position then\n        -- What we do here is get the position of the target player *relative* to the life sensor,\n        -- then get the 'magnitude' of the resulting value, which is the fancy way of saying 'length'.\n        local distance = (position.Position - lifeSensor.Position).Magnitude\n\n        -- Output the player's username and their distance.\n        print(`There is a threat! Their name is {threatUsername} and they are {math.floor(distance)} studs away!`)\n    else\n        -- Output just the player's username, and add a note about how they're too far away to know their distance.\n        print(`There is a threat! Their name is {threatUsername}! They are too far away to tell their distance.`)\n    end\nend\n\n-- Connect to the `Loop` event of the `Microcontroller` that is running the code,\n-- this will make the code within run precisely every game tick.\nMicrocontroller.Loop:Connect(function()\n    -- Get an 'array' of the player `UserId`s, this function ignores the range limit.\n    local presenceReading = lifeSensor:ListPlayers()\n\n    -- This one returns a 'dictionary' where the keys are the player `UserId's`, and\n    -- the values are the positions of the specific players, but it only includes\n    -- players within 2,000 studs of the `LifeSensor`, which is why we need\n    -- the result of `ListPlayers`.\n    local positionalReading = lifeSensor:GetPlayers()\n    \n    -- Iterate over each of the players returned by `ListPlayers`, the 'index' variable is\n    -- called `_` as is customary when defining a variable that is not ever used.\n    for _, userId in presenceReading do\n        -- If the user is whitelisted, skip to the next player using a `continue` statement.\n        if WHITELIST[userId] then continue end\n\n        -- Here, we try and get the player's position from the `GetPlayers` dictionary, if the\n        -- player is outside of the `LifeSensor`'s range, this will be `nil` and *won't* throw\n        -- any sort of error.\n        local playerPosition = positionalReading[userId]\n\n        -- Merely call the `foundThread` function, giving it the user who we're talking about,\n        -- along with their position (their position *may* or *may not* be specified.)]\n\n        -- Note: If you were to do some computation within `foundThread` that takes a lot of\n        --       time (or maybe has a `task.wait` or two), you would want to do something\n        --       like `task.spawn(foundThread, userId, playerPosition)` instead, as this\n        --       will allow this function to keep looking for other players whilst the\n        --       `foundThreat` function is running (rather than waiting for it to finish).\n        --       Look into the roblox task scheduler if you want to know more.\n        foundThreat(userId, playerPosition)\n    end\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is a craftable and spawnable non-flammable solid."}),"\n",(0,i.jsx)(n.p,{children:"It cannot be resized."}),"\n",(0,i.jsx)(n.p,{children:"At its default size (2x3x2) it has a durability of 1."}),"\n",(0,i.jsxs)(n.p,{children:["By default, its colour is ",(0,i.jsx)("span",{style:{color:"# 0FF 0"},children:"# 0ff 0"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It requires 15 ",(0,i.jsx)("code",{children:"Grass"}),", 25 ",(0,i.jsx)("code",{children:"Quartz"}),", and 5 ",(0,i.jsx)("code",{children:"Wire"})," to be crafted."]}),"\n",(0,i.jsx)(s.A,{id:"Methods",group:"group",children:"Methods"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"GetPlayers",group:"method",children:"GetPlayers() \u2192 players"}),"\n",(0,i.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,i.jsx)("i",{children:"player"})," ",(0,i.jsx)("code",{children:"UserId"}),"s and the values are ",(0,i.jsx)("i",{children:"player"})," CFrames. Only has a 2,000 stud range."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"players"})," return is a dictionary of player ",(0,i.jsx)("code",{children:"UserId"}),"s to their world CFrames. It is a dictionary with keys that are ",(0,i.jsx)("code",{children:"number"}),"s and values that are ",(0,i.jsx)("code",{children:"CFrame"}),"s."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"GetReading",group:"method",children:"GetReading() \u2192 reading"}),"\n",(0,i.jsxs)(n.p,{children:["Returns a table where the keys are ",(0,i.jsx)("i",{children:"humanoid"})," names and the values are ",(0,i.jsx)("i",{children:"humanoid"})," positions. Only has a 2,000 stud range."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"reading"})," return is a dictionary of humanoid names to their world positions. It is a dictionary with keys that are ",(0,i.jsx)("code",{children:"number"}),"s and values that are ",(0,i.jsx)("code",{children:"Vector3"}),"s."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(s.A,{id:"ListPlayers",group:"method",children:"ListPlayers() \u2192 players"}),"\n",(0,i.jsxs)(n.p,{children:["Returns an array of player ",(0,i.jsx)("code",{children:"UserId"}),"s. Ignores the 2,000 stud range limit."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)("b",{children:"players"})," return is an array of a ",(0,i.jsx)("code",{children:"number"}),"s."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},81113:(e,n,t)=>{t.d(n,{A:()=>i});t(96540);var a=t(74848);function i(e){return(0,a.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,a.jsx)("path",{fill:"currentColor",d:"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"})})}}}]);